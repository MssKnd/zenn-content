---
title: "実際のリファクタリングから考える「悪い方が良い」原則"
emoji: "🎃"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: [TypeScript]
published: false
---

:::message
著者はたびたび TypeScript で書かれたコードのリファクタリング通して、プログラミング手法の試行をしています。この記事はその取り組みの最中に思考した内容のまとめです。習熟中のため生煮えの箇所があります。
:::

リファクタリングのタイミングって難しいなと考えたことがあり、自分の思考プロセスを記録するために記事にしてみました。

# 前提条件

この記事ではまず以下のコードの考察からしたいと思います。とあるWebアプリケーションのフロントエンドで利用されている想定のコードです。

```ts:simple-path.ts
const USER_VIDEO_PAGE_PATH =
  (userId?: number, videoId?: number, timestamp?: number) => 
    `/user/${userId ?? ':userId'}/video/${videoId ?? ':videoId'}${timestamp ? `?timestamp=${timestamp}` : ''}`;
```

## 観察
これだけで何をしたいコードか、分かる方には分かるかもしれません。前提条件としてこのWebアプリケーションはユーザーに紐づく動画を視聴する機能があり、さらに動画の任意時刻を参照できる機能があるとします。

前述したコードの利用例は以下です。

```ts
const routingPath = USER_VIDEO_PAGE_PATH(); // '/user/:userId/video/:videoId'
const path = USER_VIDEO_PAGE_PATH(1000, 30); // '/user/1000/video/30'
const path = USER_VIDEO_PAGE_PATH(1000, 50, 1650753766); // '/user/1000/video/50?timestamp=1650753766'
```

利用例から、このコードには以下の要件があることが分かります。

- `'/resource/:resourceId'` 形式の path 文字列を生成する
- 上記を元に実際のリソースを表現する path 文字列を生成する
- 上記にクエリを付与した path 文字列を生成する

また、TypeScript では慣習的に定数名を `SCREAMING_SNAKE_CASE` で書きます。関数であるこのコードが定数名のように書かれているのは、最初に以下のような実装があり、前述した要件が追加されたため、既存の実装が拡張された過去がありそうです。

```ts
// 既存の実装
const PATHS = {
  HOME: '/',
  DASHBOARD: '/dashboard',
} as const;

// 要件が追加された実装
const PATHS = {
  HOME: () => '/',
  DASHBOARD: () => '/dashboard',
  USER: (userId?: number) => `/user/${userId ?? ':userId'}`,
  USER_VIDEO: // 省略：前述した USER_VIDEO_PAGE_PATH と同等の実装
} as const;
```

## 課題の整理

このコードは何が要件か観察すれば理解できるシンプルな実装ですが、いくつか課題がありそうです。

- 複数の引数が必要である場合、出力が不十分である場合が発生しうる（`'/user/1000/video/:videoId'`）
- 複数の任意クエリが必要になった場合、処理が複雑化する

可読性の面では以下が考えられます。

- 命名規則の慣習的に定数のように見えるが実際には関数である
- 複数の path を PATHS としてまとめることで関心事を凝集しているが、内部に分岐があるため一覧性が低い
- `'/resource/:resourceId'` 形式の path 文字列が必要な場面と、実際の path が必要な場面は異なるため、分岐ではなく機能として分けた方が要件を理解しやすい

また、スケールという観点でも以下のような要件が発生する可能性があります。
- それぞれの path を横断したクエリの要件が追加された場合、全ての path にクエリ条件を追加する必要がある
- フラグメント（末尾に `#message` などの # から始まる文字列）の要件に対応できない

# リファクタリング
## テストケース
まずはテストケースを用意します。今回は以下を用意しました。

```ts
describe("path", () => {
  it("パスを文字列として取得できる", () => {});
  it("指定した id を埋めた文字列を取得できる", () => {});
  it("指定した複数の id を埋めた文字列を取得できる", () => {});
  it("クエリを追加した文字列を取得できる", () => {});
  it("複数のクエリを追加した文字列を取得できる", () => {});
  it("既にクエリが入力されているPathに対してクエリを追加できる", () => {});
  it("id とクエリを追加できる", () => {});
});
```

## クラスでの実装
クラスでの実装を考えてみました。

```ts
export class Path {
  constructor(private pathString: string) {}
  toString() {
    return this.pathString;
  }
  fillId(ids: { [id: string]: string | number }) {
    for (const id in ids) {
      this.pathString = this.pathString.replace(`:${id}`, ids[id].toString());
    }
  }
  appendQueries(queries: { [query: string]: string | number }) {
    const queryString = Object.keys(queries)
      .map((key) => `${key}=${queries[key]}`)
      .join("&");
    if (this.pathString.includes("?")) {
      this.pathString = `${this.pathString}&${queries}`;
    }
    this.pathString = `${this.pathString}?${queries}`;
  }
}
```

path 情報を集約した場合にも、一覧性が良さそうに見えます。

```ts
const paths = {
  userPagePath: new Path('/user/:userId');
  userVideoPagePath: new Path('/user/:userId/video/:videoId');
}
```

実際に記載してみたら以下のようになります。

```ts
const userVideoPagePath = new Path('/user/:userId/video/:videoId');
const userVideoPagePathString = userVideoPagePath.toString(); // '/user/:userId/video/:videoId'
const filledUserVideoPagePathString = userVideoPagePath.fillId({
  userId: 1000,
  videoId: 30,
}); // '/user/1000/video/30'
const filledUserVideoPagePathStringWithQuery = userVideoPagePath.appendQueries({
  timestamp: 30,
}); // '/user/1000/video/30?timestamp=1650753766'
const filledUserVideoPagePathString_2 = userVideoPagePath.fillId({
  userId: 1200,
  videoId: 10,
}); // '/user/1000/video/30' !!!!!!!!!!!
```

良さそうに見えますが、`userVideoPagePath` で保持している path がメソッドを呼ぶたびに変更されてしまい、`Path.fillId()` の再利用ができなくなっています。

private メンバーを変更しないようにし、クラスメソッドでは文字列では無く Path のインスタンスを出力するようにします。

```diff ts
  export class Path {
+   constructor(private pathString: Readonly<string>) {}
-   constructor(private pathString: string) {}
    toString() {
      return this.pathString;
    }
    fillId(ids: { [id: string]: string | number }) {
+     const _pathString = this.pathString;
      for (const id in ids) {
+       _pathString = _pathString.replace(`:${id}`, ids[id].toString());
-       this.pathString = this.pathString.replace(`:${id}`, ids[id].toString());
      }
+     return new Path(_pathString);
    }
    appendQueries(queries: { [query: string]: string | number }) {
      const queryString = Object.keys(queries)
        .map((key) => `${key}=${queries[key]}`)
        .join("&");
      if (this.pathString.includes("?")) {
+       new Path(`${this.pathString}&${queries}`);
-       this.pathString = `${this.pathString}&${queries}`;
      }
+     new Path(`${this.pathString}?${queries}`;)
-     this.pathString = `${this.pathString}?${queries}`;
    }
  }
```


<!-- 

URLパスに関する以下の要件を満たすデータ構造を考えます。

- ベースとなるURIを保持する(例：`/user/:userId/article/:articleId`)
- 保持しているURIを文字列として取得できる
- 保持しているURIのidを埋めた文字列を取得できる
- 保持しているURIにクエリパラメーターを付与した文字列を取得できる
- 上記２つの要件を同時に満たす
- 保持しているベースURIは再利用できる（上書きされない）

まずは、Classで考えてみます。

要件を満たすテストを用意します。



 -->

